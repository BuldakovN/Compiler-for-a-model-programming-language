#pragma once
#include "Types.h"

//лексема
struct lexem {
	enum class Table_index tab; //принадлежность таблице 
	int id;						//порядковый номер в таблице
	std::string value;			//значение лексемы
	int number;					//номер лексемы по порядку
};

class Parser
{
	std::vector<lexem> declareted_identificators;	//список объявленых идентификаторов
	std::string filename;							//название файла
	std::fstream lexeme_file;						//файл с лексемами
	lexem LEX;										//лексема

	bool gl();
	bool EQ(std::string);
	bool ID();
	bool NUM();
	int err_proc(int);								//вывод ошибок
	int check_lex();
	void add();										//добавить идентификатор в список объявленных

public:
	Parser(std::string);
	void scanner();
private:
	/*--------------------------Процедуры проверки выполнения правил, описывающих входной язык--------------------------*/
	//<программа>::= 		«{» {/ (<описание> | <оператор>) ; /} «}»
	void PROG();

	//<описание>::= 		{<идентификатор> {, <идентификатор> } : <тип> ;}
	void DESCR();

	//<оператор>::= 	<составной> | <присваивания> | <условный> |
	//		<фиксированного_цикла> | <условного_цикла> | <ввода> |
	//		<вывода>
	void OPERATOR();

	//<тип>::= 		% | ! | $
	void TYPE();

	/*--------------------------Правило, определяющее оператор программы--------------------------*/
	//<составной>::= 		«{» <оператор> { ; <оператор> } «}»
	void COMP_OP();

	//<присваивания>::= 	[ let ] <идентификатор> = <выражение>
	void ASSIGN_OP();

	//<условный>:: = if <выражение> then <оператор>[else <оператор>] end_else
	void IF_OP();

	//<фикс_цикла>::= 	for «(»[<выражение>] ; [<выражение>] ; [<выражение>] «)» <оператор>
	void FOR_CICLE();

	//<условного_цикла>:: = do while <выражение> <оператор> loop
	void WHILE_CICLE();

	//<ввода>::= 		input «(»<идентификатор> {пробел <идентификатор>} «)»
	void INPUT();

	//<вывода>::= 		output «(»<выражение> { пробел <выражение> } «)»
	void OUTPUT();

	/*--------------------------Выражения языка--------------------------*/
		//<выражение>:: =	<операнд>{ <операции_группы_отношения> <операнд> }
	void EXPRESSION();

	//<операнд>::= 		<слагаемое> {<операции_группы_сложения> <слагаемое>}
	void OPERAND();

	//<слагаемое>::= 	<множитель> {<операции_группы_умножения> <множитель>}
	void SUMMAND();

	//<множитель>::= 	<идентификатор> | <число> | <логическая_константа> |
	//					<унарная_операция> <множитель> | «(»<выражение>«)»
	void MULTIPLIER();

	//<число>:: =		<целое> | <действительное>
	void NUMBER();

	/*--------------------------Операции языка--------------------------*/
		//<оп_группы_отношения>:: = 	< > | = | < | <= | > | >=
	void RATIO();

	//<оп_группы_сложения>:: = 		+ | - | or
	void ADDITION();

	//<оп_группы_умножения>:: =		*| / |and
	void MULTIPLICATION();

	//<унарная_операция>::= 		not
	void UNARY();
};