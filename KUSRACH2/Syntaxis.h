#pragma once
#include "Types.h"

//лексема
struct lexem {
	enum class Table_index tab; //принадлежность таблице 
	int id;						//порядковый номер в таблице
	std::string value;			//значение лексемы
	int number;					//номер лексемы по порядку
};

class Syntaxis
{
	std::string filename;		//название файла
	std::fstream lexeme_file;	//файл с лексемами
	lexem LEX;					//лексема

	bool gl();
	bool EQ(std::string);
	bool ID();
	bool NUM();
	std::string get();
	int err_proc(int);

public:
	Syntaxis(std::string);
	void scanner();

private:

/*--------------------------Процедуры проверки выполнения правил, описывающих входной язык--------------------------*/

	//<программа>::= 		«{» {/ (<описание> | <оператор>) ; /} «}»
	void PROG();

	//<описание>::= 		{<идентификатор> {, <идентификатор> } : <тип> ;}
	void DESCR();
	
	//<оператор>::= 	<составной> | <присваивания> | <условный> |
	//		<фиксированного_цикла> | <условного_цикла> | <ввода> |
	//		<вывода>
	void OPERATOR();

	//<тип>::= 		% | ! | $
	void TYPE();


/*--------------------------Правило, определяющее оператор программы--------------------------*/
	//<составной>::= 		«{» <оператор> { ; <оператор> } «}»
	void COMP_OP();

	//<присваивания>::= 	[ let ] <идентификатор> = <выражение>
	void ASSIGN_OP();

	//<условный>:: = if <выражение> then <оператор>[else <оператор>] end_else
	void CONDITION_OP();

	//<фикс_цикла>::= 	for «(»[<выражение>] ; [<выражение>] ; [<выражение>] «)» <оператор>
	void FOR_CICLE();

	//<условного_цикла>:: = do while <выражение> <оператор> loop
	void WHILE_CICLE();

	//<ввода>::= 		input «(»<идентификатор> {пробел <идентификатор>} «)»
	void INPUT();

	//<вывода>::= 		output «(»<выражение> { пробел <выражение> } «)»
	void OUTPUT();


/*--------------------------Идентификатор, буква или цифра--------------------------*/
	//<идентификатор>::= 	<буква> {<буква> | <цифра>}
	void IDENT();

	//<бувка>
	void LETTER();

	//<цифра>
	void DIGIT();


/*--------------------------Выражения языка--------------------------*/
	//<выражение>:: =	<операнд>{ <операции_группы_отношения> <операнд> }
	void EXPRESSION();

	//<операнд>::= 		<слагаемое> {<операции_группы_сложения> <слагаемое>}
	void OPERAND();

	//<слагаемое>::= 	<множитель> {<операции_группы_умножения> <множитель>}
	void SUMMAND();

	//<множитель>::= 	<идентификатор> | <число> | <логическая_константа> |
	//					<унарная_операция> <множитель> | «(»<выражение>«)»
	void MULTIPLIER();

	//<число>:: =		<целое> | <действительное>
	void NUMBER();

	//<лог_константа>::= 	true | false
	void BOOL();


/*--------------------------Правила, определяющие целые числа--------------------------*/
	//<целое>::= 		<двоичное> | <восьмеричное> | <десятичное> | <шестнадцатеричное>
	void INTEGER();

	//<двоичное>::= 		{/ 0 | 1 /} (B | b)
	void BIN();

	//<восьмеричное>::= 	{/ 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 /} (O | o)
	void OCT();

	//<десятичное>:: = { / <цифра> / }[D | d]
	void DEC();

	//<шестнадцатеричное>::=	<цифра>{ <цифра> | A | B | C | D | E | F | a | b |
	//			c | d | e | f } (H | h)
	void HEX();


/*--------------------------Правила, описывающие действительные числа--------------------------*/
	//<действительное>::= 	<числовая_строка> <порядок> |
	//			[<числовая_строка>] . <числовая_строка>[порядок]
	void FLOAT();

	//<числовая_строка>::= 	{/ <цифра> /}
	void NUMBER_STR();

	//<порядок>::= 		( E | e )[+ | -] <числовая_строка>
	void ORDER();


/*--------------------------Операции языка--------------------------*/
	//<оп_группы_отношения>:: = 	< > | = | < | <= | > | >=
	void RATIO();

	//<оп_группы_сложения>:: = 		+ | - | or
	void ADDITION();

	//<оп_группы_умножения>:: =		*| / |and
	void MULTIPLICATION();

	//<унарная_операция>::= 		not
	void UNARY();
};

